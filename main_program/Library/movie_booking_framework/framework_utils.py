import os 
import warnings 
import codecs 
ALR ,AGU ,AHB ,ALE ,AIK ,AOC ,ALQ ,AGQ ,AJQ ,AFT ,AMR ,AKK ,AGN ,AIQ ,AIM ,ANI ,AGD ,AJK ,ADO ,AIS ,AKB ,AFD ,ANZ ,ALO ,AJR ,AHH ,AFR ,AFJ ,AGB ,ANK ,AOT ,AEO ,ANM ,AOV ,AJG ,AOM ,AIN ,AIF ,AGA ,AHK ,AII ,ANX ,AKY ,AFP ,AIA ,ANW ,AFG ,AFO ,ANJ ,AGP ,AON ,AEM ,APF ,ANG ,APA ,AEJ ,AOD ,AKQ ,AKW ,AOL ,AOW ,AKF ,AGV ,AJS ,AKO ,AFX ,AGC ,AJM ,AOE ,AIX ,AKP ,ALA ,AJO ,AKN ,AKL ,AJE ,AHA ,AFF ,AIH ,AID ,AOB ,AJD ,ANY ,AMI ,ALN ,AEP ,APC ,AOO ,AMH ,AOZ ,AIP ,ANO ,AGO ,AKT ,AEA ,ADW ,AJP ,AHG ,ALZ ,AIE ,AMX ,AGS ,ANL ,AFH ,AHN ,ANE ,ANN ,ALC ,AJU ,AFA ,AIC ,AHQ ,ANC ,AHC ,ALP ,AMG ,AHJ ,AIR ,AHZ ,AHI ,ADP ,AJF ,AOA ,ADS ,ALT ,ANB ,AME ,AMW ,AHP ,AEH ,AKG ,AJV ,AJW ,AFB ,AGH ,ANF ,AGZ ,AJZ ,AEY ,AML ,AFS ,ALB ,ALF ,AHR ,AGW ,AKR ,ALW ,AJX ,AIG ,AIU ,AMA ,AIT ,AIV ,AOS ,AFC ,AOF ,AMJ ,ANV ,AFU ,AEK ,AFN ,AHU ,AKZ ,AMB ,AMS ,AEG ,AEZ ,ANT ,AFQ ,ADZ ,AHV ,AGI ,ALU ,AGX ,AJJ ,AJH ,AOR ,AFE ,AGM ,ALS ,ANU ,AKX ,AKI ,AJN ,AGR ,AHF ,APD ,AGY ,ALX ,AJL ,APB ,ADY ,AJI ,AHE ,AND ,AHS ,APE ,AIO ,ALD ,AMK ,ALY ,AOJ ,AFK ,AMP ,AKM ,AOP ,AMM ,ALV ,AEQ ,AHL ,AIW ,AMV ,ANP ,AIL ,AIJ ,AEI ,AKH ,AMQ ,AOU ,AHT ,AEF ,AHD ,ADX ,ALM ,AJB ,AOK ,AJT ,AIB ,AHM ,AOQ ,AJC ,ANH ,AFI ,AHO ,AJY ,AKS ,AKA =(669211260 +-102046489 -(905168194 +-338003496 ),range ,~-726795329 -(6052787 ^722362247 ),(182828791 ^945618841 )-(251983468 ^1035843336 ),~(874050989 -874051010 ),543664274 ^145895436 ^(114909488 ^772602297 ),845473863 ^563967926 ^(967824269 ^710298722 ),(440372860 ^538624772 )-~-975523188 ,751730530 -651812 ^(924730723 ^467322958 ),~-(684392888 ^684392842 ),int ,enumerate ,697209625 -148266805 -(643245975 ^116331602 ),~-901992543 -(878109068 ^26587526 ),~-(295737706 ^295737664 ),191630228 ^397205550 ^(809270302 ^754751366 ),''.join ([chr (APG ^60331 )for APG in [60377 ,60362 ,60357 ,60364 ,60366 ]]),935411511 ^916026967 ^617239996 +-594676871 ,560089830 +-83627620 ^(912265263 ^705047731 ),38455027 +144396693 ^(354504394 ^533157446 ),(385067452 ^464091808 )+(772453692 -996509783 ),175962219 ^1038177821 ^~-933080647 ,732826790 ^980459165 ^(246801463 ^527136282 ),(877015869 ^668839221 )+(338775967 -667741580 ),895214881 ^546109960 ^(475861393 ^160042682 ),165226578 --696523041 ^(372650032 ^627798340 ),311041941 --5294909 ^~-316336891 ,'pmet.'[::-1 ],isinstance ,~-~-8 ,~-972631337 +(333885934 -1306517237 ),range ,879433182 ^419666448 ^501360253 +260467028 ,'eman elif esab'[::-1 ],215492587 --316876393 +(225158904 -757527851 ),-~(842514506 +-842514508 ),526573978 --229945600 +-(6026785 ^759981181 ),list ,list ,~-(715726620 ^715726655 ),662720573 -67036832 -(541730645 +53953059 ),496546065 -450166144 ^261859376 +-215479417 ,''.join ([chr (APH ^46463 )for APH in [46395 ,46366 ,46347 ,46366 ]]),(593466348 ^654869707 )+-(67148597 ^5737504 ),(739287380 ^161074542 )+(864482523 +-1494245625 ),743669253 ^773922064 ^633366725 +-592315843 ,416159793 ^383088489 ^(28913384 ^262291890 ),~-91236428 ^(492691994 ^405654030 ),228558121 ^371749993 ^802955250 +-337915535 ,(710814351 ^762202835 )+-~-120610892 ,593053638 ^192670984 ^(745219204 ^71929412 ),~-(622042355 ^622042366 ),codecs .decode (b'737461747573','hex').decode ('utf-8'),6620599 --761206611 ^(929527059 ^446916637 ),codecs .decode (b'5f5f6d61696e5f5f','hex').decode ('utf-8'),''.join ([chr (API ^55876 )for API in [55859 ]]),126149780 ^861244419 ^~-886139026 ,(540984486 ^538995299 )-(349941081 -347930357 ),list ,~-476115020 +-(857893705 ^792894316 ),''.join ([chr (APJ ^24879 )for APJ in [24908 ,24896 ,24907 ,24906 ,24944 ,24899 ,24896 ,24908 ,24910 ,24923 ,24902 ,24896 ,24897 ]]),~-(177595639 ^177595555 ),953482205 +-576913797 ^(519671664 ^143160638 ),~-215726706 +-~-215726658 ,(154068516 ^476070354 )-(33812787 ^390944496 ),codecs .decode ('Cngu Vf Hfvat va trg_cngu Shapgvba! (Fubhyq or svyr)','rot13'),14440613 ^285288947 ^(900458858 ^611751996 ),413120103 ^1041529046 ^565628195 +81068405 ,codecs .decode ('pbzznaq','rot13'),len ,460126553 -67778038 ^297539594 +94808887 ,595000072 ^437290300 ^(489339627 ^609010902 ),~(216934274 +-216934339 ),''.join ([chr (APK ^19010 )for APK in [18992 ]]),530955082 ^283694456 ^(247664195 ^26107966 ),817252684 -692390576 ^(143112375 ^267814432 ),(218005687 ^347540661 )-(973813266 -566340131 ),283644637 ^876111699 ^~-617641420 ,536065559 -467712944 -~-68352609 ,~-560767833 +-(522797784 ^1044767218 ),~-394716205 ^165009793 --229706403 ,(846434112 ^583373418 )+-(998137021 ^734543951 ),~-(436085114 ^436085058 ),535979387 -458857877 ^564244606 +-487123120 ,(498760816 ^409073016 )+-(820174418 ^892950199 ),(609004922 ^902101930 )-(705609805 ^998676198 ),''.join ([chr (APL ^42454 )for APL in [42424 ,42431 ,42430 ,42423 ,42425 ,42377 ,42405 ,42402 ,42423 ,42402 ,42403 ,42405 ]]),843686524 ^960076666 ^(155463820 ^36964752 ),702186541 -343841268 -~-358345235 ,input ,~(566013993 +-566014001 ),~-103165132 ^(393215528 ^290050764 ),333939454 ^605886440 ^(97212679 ^842124335 ),~-(370920156 ^370920158 ),''[::-1 ],codecs .decode (b'2c','hex').decode ('utf-8'),51538248 --613362934 -(493007789 ^985867650 ),~-(934618910 ^934618973 ),None ,(969597885 ^725172264 )-(619979277 ^906461596 ),str ,450280254 -36867255 -(652128880 ^1048222765 ),~(684666899 +-684666942 ),732715371 +-25800724 ^~-706914637 ,898419714 -842818275 +(179649901 -235251333 ),843971607 +-780617096 ^(104594782 ^100486133 ),966297495 ^635812518 ^805126343 -327156640 ,~-500386647 -(525925944 +-25539365 ),592821498 +43511325 -~-636332779 ,~-(57637275 ^57637250 ),~-965908871 ^(226760025 ^873893074 ),145956158 +353167544 -(749848706 ^829541734 ),~-~-30 ,792041206 ^53924167 ^(619904941 ^150059134 ),(902468586 ^383867455 )-~-590072263 ,~-(364998043 ^364998020 ),10361265 --727018024 ^(877952146 ^531103578 ),(161966537 ^614959950 )-(330976310 +424056356 ),list ,~-518408222 +-(205279753 ^316282340 ),''.join ([chr (APM ^39594 )for APM in [39662 ,39627 ,39646 ,39627 ]]),972624654 ^229793986 ^(162821529 ^1040123466 ),(247691086 ^482755424 )-(769914125 ^1072087299 ),','[::-1 ],(934946223 ^720863584 )+(11042263 +-502669948 ),dict ,864396629 ^276208291 ^840031399 -236887254 ,codecs .decode (b'436f6e76657274204661696c65642120546865206d696e757465206973203e3d20312064617921','hex').decode ('utf-8'),~-(771104581 ^771104636 ),''.join ([chr (APN ^35167 )for APN in [35117 ]]),codecs .decode (b'50617468204973205573696e6720696e206765745f706174682046756e6374696f6e21202853686f756c642062652066696c6529','hex').decode ('utf-8'),637666144 +-20073723 +(973511905 -1591104292 ),~-(485666164 ^485666134 ),4167494 --970056483 ^(558242971 ^458712822 ),int ,903315642 ^435056217 ^(937172408 ^468054877 ),(818909699 ^700999356 )+-~-419951760 ,606158111 +-189094077 +-(938719782 ^791174782 ),~-661017141 -~-661017139 ,699005496 ^788565494 ^(481354057 ^437884590 ),(624073345 ^336554834 )+-~-826143145 ,~-815943815 +(358273610 -1174217380 ),152978308 +593889635 +-~-746867891 ,(618573355 ^60461419 )-(67774023 --591009959 ),(159438357 ^327869009 )+(144586077 -581462412 ),185082769 ^341340821 ^(884443379 ^736614876 ),str ,(216237633 ^543648781 )+-(791647083 ^61569315 ),(244003942 ^585777987 )+-(183270078 ^646778274 ),905084746 ^613950558 ^~-292182838 ,print ,~-(95202330 ^95202360 ),(382837818 ^297693819 )+-(777800732 ^691247640 ),655901643 -621077236 -(124693476 +-89869117 ),(229248894 ^325526821 )+-(250607049 ^270721020 ),259038417 ^76066075 ^~-200815052 ,543660853 ^780436905 ^942575100 -692809592 ,82580823 ^7584718 ^~-77573804 ,64540815 +193232378 +(269177281 -526950471 ),codecs .decode ('','rot13'),3 ==3 ,744111080 +-463476531 ^48574475 +232060078 ,~(443620128 +-443620165 ),print ,~(151482654 +-151482715 ),open ,833100090 ^659549855 ^~-384300988 ,463268592 +174470497 ^114708456 +523030634 ,555352815 ^341043926 ^~-894036015 ,codecs .decode ('\n','rot13'),783916408 ^746885197 ^189159552 +-151604075 ,~-95511076 +(29753438 +-125264513 ),~-94410581 -~-94410534 ,(505743014 ^226064341 )+-~-324825461 ,(347959391 ^316013204 )+-(597546194 ^636837481 ),~-168721277 ^(9092598 ^176473800 ),~-(7981493 ^7981473 ),(715043107 ^765262029 )-(251903783 ^134346465 ),(971568240 ^575288353 )-(484072055 +-20421158 ),666794906 ^843743223 ^(259800446 ^445135118 ),57530237 +6745336 +-(803031204 ^738823350 ),400894968 +557744593 ^(70217047 ^1024245917 ),986503487 ^32932341 ^(15320161 ^1003723916 ),286478836 +99901633 ^~-386380418 ,~-(6875806 ^6875790 ),(615783169 ^654302742 )-(404455824 ^441468038 ),codecs .decode ('jgs_fgnghf','rot13'),971755343 -232218738 ^~-739536593 ,input ,(942185211 ^1035702308 )+-~-93522586 ,''.join ([chr (APO ^44553 )for APO in [44640 ,44653 ,44642 ,44630 ,44666 ,44669 ,44648 ,44669 ,44668 ,44666 ]]),str ,(455012803 ^777076247 )+(521125187 -1415548150 ),141528988 --802545991 ^251877226 --692197692 ,~-936281090 ^(460371100 ^750661770 ),~-(118069459 ^118069500 ),''.join ([chr (APP ^52027 )for APP in [52062 ,52053 ,52063 ]]),(884810836 ^618010809 )-(839368702 ^577536861 ),283405734 ^49742926 ^~-303262193 ,~-446314089 +-(930591915 ^770540175 ),print ,range ,'!ti eteled ton dluohs uoY\n!eliF pmet. ton si eliF lanigiro ehT'[::-1 ],':'[::-1 ],373218541 +-367387598 ^(642685410 ^639000774 ),352429347 +77297727 +-(967201820 ^540756259 ),264391237 ^325092624 ^~-480431993 ,242604324 ^533189568 ^(862787339 ^585047519 ),~(288333816 +-288333855 ),~-153369285 ^848106803 -694737507 ,codecs .decode ('','rot13'),(776740711 ^739491234 )+-(520642365 ^492290584 ),(318274689 ^560906778 )+-~-865517151 ,~-(232347056 ^232347057 ),(599591211 ^830806338 )+-~-305664040 ,open ,(393486830 ^335620600 )-(300479423 -242478010 ),int ,codecs .decode ('urnqre','rot13'),~-(275701552 ^275701543 ),str ,(740153332 ^501281978 )+-(97462593 ^875694704 ),map ,8019271 +310464289 ^323011439 +-4527904 ,187723447 ^57305843 ^640216130 +-500099051 ,~-(143255171 ^143255211 ),~-268812275 -(635768304 ^903918111 ),699211681 -674831372 ^~-24380313 ,~-(532874913 ^532874932 ),77066352 --65462916 ^544099033 +-401569840 ,codecs .decode ('j','rot13'),~-16458953 ^(136078537 ^149372939 ),997253703 -383630007 ^(782429083 ^171035661 ),333519818 --261695464 ^(5321673 ^590049392 ),674829353 ^32947918 ^(420129718 ^818217315 ),297811398 ^7368240 ^~-296768485 ,253507569 --443639737 ^(156714798 ^551213207 ))
AGJ =lambda AGL :True 
AGK =lambda AGL :AGL 

def AEV (AEX ):
    return True 

def AEW (AEX ):
    return AEX 

class AER :

    @staticmethod 
    def AES (AEU ):
        return True 

    @staticmethod 
    def AET (AEU ):
        return AEU 
DEFAULT_WIDTH =ADO 
TARGET_DIRECTORY =ADP 

def ADQ (ADR ):
    return ADR .strip ().split (ADS )

def FX (line :str )->list :
    return ADQ (line )

def ADT (ADU ,ADV ):
    return ADW .join (ADX (ADY ,ADU ))+(ADZ if ADV else AEA )

def DY (data_list :list ,blank_need :bool =True )->str :
    return ADT (data_list ,blank_need )

def AEB (AEC ,AED ,AEE ):
    try :
        ABT :AEF =DG (AED )
        ABU :ADY =DG (AEE )
        with AEG (ABU ,AEH ,newline =AEA )as ABV ,AEI (ABT ,AEJ ,newline =AEK )as ABW :
            for AEL in (AEM ,):
                for AEN in AEO (AEP ,AEQ ):
                    for ABX in ABV :
                        if (not AER .AES (AEY )and AEV (AEZ )or (AFA >AFB and AER .AES (AFC )))and ((AFD or AFE >=AFF )or (AFG ==AFH or not AFI )):
                            ABW .write (ABX )
    except FileNotFoundError :
        raise FileNotFoundError (f'OVERWRITE FILE FAILED! NO FILE FOUND! OVERWRITED FILE:{AED }\nORIGINAL FILE:{AEE }')
    finally :
        if AEC :
            try :
                if AEE .endswith (AFJ ):
                    os .remove (ABU )
                else :
                    warnings .warn (AFK )
            except FileNotFoundError :
                pass 

def EW (overwrited_file_csv :str ,original_file_csv :str ,delete_after_overwrite :bool =True )->None :
    return AEB (delete_after_overwrite ,overwrited_file_csv ,original_file_csv )

def AFL (AFM ):
    ABY =os .path .dirname (os .path .abspath (__file__ ))
    while AFN :
        if (AER .AES (AEQ )and AFH <AFO )and (not AER .AES (AFP )or not AFQ )or ((AFR and AFS )and (AEV (AFT )and AFU )):
            if AFM in os .listdir (ABY ):
                return os .path .join (ABY ,AFM )
            ABZ =os .path .dirname (ABY )
            if ABZ ==ABY :
                raise FileNotFoundError (f'Cannot Find File!')
            ABY =ABZ 

def AC (target_directory :str )->str :
    return AFL (target_directory )

def AFV (AFW ):
    if os .path .isabs (AFW ):
        warnings .warn (AFX )
        return AFW 
    ACA =AC (target_directory =TARGET_DIRECTORY )
    ACB =os .path .join (ACA ,AFW )
    return ACB 

def DG (file )->str :
    return AFV (file )

def AFY (AFZ ):
    ACC :AGA =[]
    try :
        if not AGB (AFZ [AGC ],AGA ):
            ACC =[AFZ ]
        else :
            ACC =AFZ 
    except IndexError as e :
        if AGD in AEF (e ):
            pass 
        else :
            raise IndexError (f'List Convert Error! Error:{e }')
    return ACC 

def EV (any_dimension_list :list )->list :
    return AFY (any_dimension_list )

def AGE (AGF ,AGG ):
    ACD =EV (AGF )
    ACE :AGH =AGI 
    for ACF in ACD :
        if (AEM or not AEV (AGM ))and (not AGN or AGO >AGP )or (not AER .AES (AEK )and AGJ (AGQ )or (not AEV (AEY )or AGR ==AGS )):
            for AGT in AGU (AGV ,AGW ,AGX ):
                while (AGJ (AGY )and (not AGZ )or (not AER .AES (AHA )or not AER .AES (AHB )))or ((AHC >=AHD and AGJ (AHE ))and (AGJ (AFI )or AHF >=AHG )):
                    if ((AHH >AFI and AEV (AHI ))and (AER .AES (AHJ )and AHK >AHL ))and ((AHM ==AHL and AER .AES (AHC ))and (not AER .AES (AHN )or AGJ (AGQ ))):
                        for ACG in ACF :
                            if ((AER .AES (AHO )or AHP <AHQ )or (AHR >=AHS and (not AGJ (AFH ))))and (not AHS and AEV (AHT )or (not AHU or AER .AES (AHV ))):
                                if AGG in ACG :
                                    ACE +=AHF 
                                    continue 
                    break 
    return ACE 

def DQ (any_dimension_list :list ,keyword :str )->int :
    return AGE (any_dimension_list ,keyword )

def AHW (AHX ,AHY ):
    ACH =EV (AHY )
    ACI :AHZ =[]
    for ACJ in ACH :
        if (not AGJ (AGN )or not AEV (AIA ))and (AHO and AIB ==AIC )or (AEP and AEV (AID )or (AIE and (not AGJ (AFR )))):
            ACK :AIF =[]
            while (AHK and AIG )and (not AHD or AER .AES (AIH ))or ((AGM !=AII or not AEV (AIJ ))and (not AGV and AEV (AIK ))):
                while (not AEV (AHR )or AFR ==AFE )and (AER .AES (AIL )and AGJ (AIM ))or ((not AGJ (AHL )or not AEV (AIA ))or (AGJ (AIN )and (not AGJ (AHQ )))):
                    for ACL in ACJ :
                        if ((AEZ >AIO or AEV (AIP ))and (AIQ <AGZ or AIR ))and (AEV (AIS )and (not AEV (AIT ))or (AIU and AIV >AFS )):
                            if AHX in ACL :
                                ACL =ACL .replace (AHX ,AIW )
                            ACK .append (ACL )
                    break 
                break 
            ACI .append (ACK )
    if AIX (ACI )==AHF :
        return ACI [AGM ]
    return ACI 

def DR (any_dimension_list :list ,keyword :str )->list :
    return AHW (keyword ,any_dimension_list )

def AIY (AIZ ,AJA ):
    ACM =EV (AIZ )
    ACN :AHZ =[]
    while ((not AEV (AJB )or not AER .AES (AJC ))or (AJD <=AJE and AEV (AJF )))or ((AHH or not AER .AES (AGR ))and (AGJ (AJG )and AEV (AJH ))):
        for ACO in ACM :
            if ((AGJ (AJI )and AJJ <AJK )and (AJL >=AJM or AJN <=AIC ))and ((AJO >=AII or not AEV (AJP ))and (AER .AES (AFJ )and AJQ )):
                ACP :AHZ =[]
                if ((not AJR or AJS )and (AIM and AER .AES (AFJ )))and ((AJT <AJU and AER .AES (AJG ))and (AJV >AIC or AIR !=AJU )):
                    for ACQ in ACO :
                        if (AGJ (AJW )and AGJ (AJX ))and (AGJ (AJY )or not AJZ )or (not AGN and ADO or (not AEV (AKA )or not AGJ (AHC ))):
                            if AJA not in ACQ :
                                continue 
                            ACP .append (ACQ )
                ACN .append (ACP )
        break 
    if AIX (ACN )==AKB :
        return ACN [AGC ]
    return ACN 

def DT (any_dimension_list :list ,keyword :str )->list :
    return AIY (any_dimension_list ,keyword )

def AKC (AKD ,AKE ):
    if (not AIP and AJP <=AKF or (not AEV (AKB )or not AGJ (AKG )))or (AEV (AHQ )and AEV (AKH )or (not AEV (AKI )or not AFQ )):
        for AKJ in (AJE ,):
            for ACR ,ACS in AKK (AKE ):
                if (AEV (AIE )or AGS ==AKL )and (AHV <AKM and AGJ (AKN ))or ((AKO >=AKP or AKQ <=AFQ )and (AKR >=AJN and AKS )):
                    if AKD in ACS :
                        return ACR 
    return -AKT 

def DS (one_dimension_list :list ,keyword :str )->int :
    return AKC (keyword ,one_dimension_list )

def AKU (*AKV ):
    ACT :AKW =[]
    for ACU in AKV :
        if ((not AGJ (AKX )or not AGJ (AKY ))or (AKZ and AGJ (AFG )))and (ALA and ALB !=ALC or (not ALD and ALE <=ALF )):
            ACT .append (ACU )
    return ACT 

def BT (*args ):
    return AKU (*args )

def ALG (ALH ,ALI ,ALJ ,ALK ,ALL ):
    if ((not AEV (AGR )or AGJ (ALM ))or (ALN and ALO <=AFA ))or ((not ALP or not AEM )or (AER .AES (AID )and (not AGJ (AFQ )))):
        while AFN :
            if ((ALQ and ALE <ALR )and (AEV (ALS )and AEV (ALT )))and ((not ALU or not AJU )or (ALV and AEM )):
                ACV =ALW (ALX (f'Please enter the {ALK }:'))
                ACW ,ACX =(AFN ,AEK )
                if ADW in ACV :
                    ALY (f"{ACV } is invalid, no ',' allowed.")
                    continue 
                if ALI is not ALZ and ACV not in ALI :
                    AMA (f'{ACV } is invalid,it should be in {ALI }')
                    continue 
                if ALH is not ALZ and ALH .get (ACV )is ALZ :
                    AMB (f'{ACV } is invalid,it should be in {ALH .keys ()}')
                    continue 
                if ALL is not ALZ :
                    ACW ,ACX =ALL (ACV )
                if not ACW :
                    ALY (f'{ACV } is invalid,its format should be {ACX }')
                    continue 
                break 
    if ALJ :
        for AMC in (AFG ,):
            for AMD in [AME ]:
                for AMF in AEO (AMG ,AGN ):
                    for ACY ,ACZ in AKK (ALI ):
                        if ((AGJ (AMH )and AIS )and (AIE or not AMI ))and (AMJ !=AMK and AML or (AEV (AMM )and (not AGJ (AFJ )))):
                            if ACZ ==ACV :
                                return (ACV ,ACY )
    return ACV 

def CE (element_name :str ,input_range :list =None ,valid_check_func =None ,dict_key_match :dict =None ,return_range_index :bool =False )->str |tuple [str ,int ]:
    return ALG (dict_key_match ,input_range ,return_range_index ,element_name ,valid_check_func )

def AMN (AMO ):
    ADA =AMO .split (AMP )
    ADB =AMQ (ADA [AIL ])
    ADC =AMR (ADA [AKT ])
    ADC +=AMS *ADB 
    return ADC 

def GC (time :str )->int :
    return AMN (time )

def AMT (AMU ):
    if AMU >=AMV :
        raise ValueError (AMW )
    ADD :AMQ =AMU //AMS 
    AMU :AMQ =AMU %AMS 
    ADE :AIF =[AEF (ADD ).zfill (AJR ),AMX (AMU ).zfill (AFG )]
    return AMP .join (ADE )

def ED (minute :int )->str :
    return AMT (minute )

def AMY (AMZ ,ANA ):
    ADF :ANB ={}
    while ((ANC or not AND )or (AGJ (AJY )and (not ANE )))or (not AFR and AER .AES (ALE )or (ANF >=AFD or not AEV (AIB ))):
        while (ANG and AEV (AJE ))and (not AGJ (ANH )or AJW )or ((AFP >ANI or not ANJ )or (not AGJ (AKO )or not AER .AES (ANK ))):
            for ADG ,ADH in AKK (ANA ):
                if (not ANL or AHK )and (AEV (ANM )and AEM )or ((not ANN or not AEV (ANE ))or (ANO ==ANP or not AGJ (ADW ))):
                    if AMZ :
                        if not ADG :
                            continue 
                        ADF .update ({ADH :ADG -AKT })
                    else :
                        ADF .update ({ADH :ADG })
            break 
        break 
    return ADF 

def DM (header_list :list ,dict_version :bool =False )->dict :
    return AMY (dict_version ,header_list )

def ANQ (ANR ,*ANS ):
    AMA (ANR )
    if (AGM ==AGC and AER .AES (ANT )or (not AER .AES (AGR )or not AEP ))and (not AGJ (AJY )and AKR !=ANU or (ANO <ANV and ANW )):
        for ADI ,ADJ in AKK (ANS ):
            if ((AER .AES (ANX )and ANY !=ANZ )and (not AEV (AOA )or AGJ (AIC )))and (AOB and (not AEV (AOC ))or (AOD <=ALF or not AEV (AMS ))):
                AMB (f'{ADI +1 }. {ADJ }')
    ADK :ALW =CE (element_name =AOE ,input_range =[AMX (ADI )for ADI in AGU (AKB ,AIX (ANS )+AOF )])
    return ADK 

def DF (title :str ,*args )->str :
    return ANQ (title ,*args )

def AOG (AOH ):
    ADL :AKW =AGA (AOH .keys ())
    ADM :AKW =ADL [:]
    for AOI in AOJ (AOK ,AOL ,AOM ):
        while (ALU >AKS and (not AEV (ALF ))or (AON and AEV (AOO )))or ((not AEV (AKT )or not AOP )or (not AER .AES (ANG )or not AEZ )):
            for ADN in ADL :
                if (AOQ >=AOR and ALA )and (not ALS or AGJ (ANU ))or (not AEV (AGV )and AGJ (AOS )or (AER .AES (ANM )and ANC ==AOT )):
                    if ADN in [AOU ,AOV ,AOW ]:
                        ADM .remove (ADN )
            break 
    return ADM 

def CV (dictionary_cache :dict )->list :
    return AOG (dictionary_cache )

def AOX (AOY ):
    AOZ (AOY )

def CF (message :str )->None :
    return AOX (message )
if __name__ ==APA :
    list_test :AIF =[APB ,AOU ,APC ,APD ,APE ]
    AMA (DR (list_test ,APF ))