from main_program .Library .movie_booking_framework import id_generator as idg
from main_program .Library .data_communication_framework import cache_csv_sync_framework as ccsf
from main_program .Library .cache_framework import data_dictionary_framework as ddf
from main_program .Library .movie_booking_framework import movie_list_framework as mlf
from main_program .Library .movie_booking_framework import movie_seats_framework as msf
from ..cache_framework.data_dictionary_framework import EZ ,FD
from main_program .Library .movie_booking_framework import framework_utils as fu
import codecs 
AAV ,UR ,XJ ,ABI ,QG ,UU ,AAI ,SZ ,AAS ,ZJ ,PZ ,ZI ,YZ ,ZA ,SU ,WC ,AAQ ,AAK ,WV ,AAP ,YJ ,ZP ,ZZ ,VA ,YK ,TZ ,YH ,WJ ,AAE ,WR ,OH ,OX ,WT ,UO ,ZW ,SX ,ZF ,OZ ,AAC ,VG ,RA ,ZH ,OT ,AAG ,AAJ ,AAH ,PO ,AAL ,SM ,VB ,AAW ,VS ,QI ,WI ,TX ,YF ,RY ,XF ,AAO ,UE ,YS ,ZG ,AAD ,YN ,TA ,RT ,OY ,YX ,XC ,YL ,XB ,VM ,SY ,OV ,QV ,VR ,TR ,ABB ,UB ,TS ,UZ ,ZL ,TH ,PC ,ZQ ,QB ,PT ,XU ,XG ,QW ,XD ,WO ,OG ,WW ,VT ,SW ,XA ,SE ,QC ,ZD ,ZB ,VN ,WH ,XZ ,YY ,RQ ,AAM ,RC ,RR ,QF ,OE ,SN ,ABC ,SL ,WU ,RJ ,WB ,WP ,VJ ,OF ,XP ,QT ,WZ ,OD ,SO ,XH ,PU ,QY ,UG ,RU ,YM ,AAN ,QE ,VD ,UD ,PW ,SV ,XT ,YE ,XI ,VH ,QZ ,TY ,WF ,XL ,QH ,VC ,UC ,XV ,WY ,VZ ,SB ,XO ,QK ,RZ ,ZC ,TE ,ZY ,UQ ,PP ,YD ,PQ ,WQ ,PD ,TG ,XK ,QS ,ZX ,UN ,AAZ ,OS ,YR ,TV ,TF ,ABH ,QX ,VE ,ZO ,WX ,UP ,TW ,AAY ,QQ ,WM ,WL ,ZK ,QA ,RS ,XS ,ZN ,WK ,TD ,XR ,VL ,AAR ,QJ ,AAB ,ZE ,VU ,OR ,PB ,VQ ,QP ,QR ,ABK ,AAT ,SA ,SC ,WA ,WN ,YW ,XE ,AAF ,QD ,XM ,YQ ,TU ,WS ,VO ,AAU ,SD ,XN ,VP ,ABA ,YU ,YG ,AAA ,XQ ,PS ,YO ,PY ,TB ,YP ,YT ,ZS ,WG ,PV ,UA ,ZR ,YV ,ZM ,WE ,ABD ,UF ,UH ,TC ,PR ,UY ,QU ,YI ,VF ,RB ,AAX ,ABJ ,WD ,TT =(596495982 +118570238 ^(497953430 ^925967518 ),''.join ([chr (ABL ^26863 )for ABL in []]),618411372 --94811970 -(482865884 +230357438 ),~-(489769601 ^489769658 ),(266584363 ^157065219 )+-~-113205522 ,bool (16 ),'trats_emit_eivom'[::-1 ],174258862 +466563261 -~-640822099 ,40972972 ^894442949 ^737436758 --187484942 ,844938073 -617535981 ^(327775266 ^503616853 ),~-(656043319 ^656043320 ),~-(630237425 ^630237370 ),(889283390 ^691047813 )-(235799677 ^306178759 ),~-577484353 ^122861788 --454622513 ,297027150 ^647262521 ^(912979871 ^21676240 ),(383915719 ^441623705 )+-(543438763 ^752125430 ),~-672780407 ^(344306608 ^1016882124 ),~-498548770 -(57530584 ^517662485 ),~-(713820046 ^713820072 ),691581597 -270096671 +(530751016 -952235873 ),848003069 ^175077635 ^218483215 --735984833 ,(296106427 ^1056710876 )-(184577405 ^609907758 ),17386167 ^581597687 ^(98279839 ^645436101 ),codecs .decode ('PVARZN_ahzore','rot13'),(387958922 ^1020498821 )-(234656612 ^640731577 ),640222819 ^1031485090 ^(902087633 ^781644561 ),int ,(195036382 ^566319117 )+(685299456 +-1396323274 ),222355701 -115231034 ^~-107124654 ,873610396 ^940192294 ^(681283114 ^612597978 ),''.join ([chr (ABM ^41796 )for ABM in [41766 ,41765 ,41783 ,41761 ,41828 ,41762 ,41773 ,41768 ,41761 ,41828 ,41770 ,41765 ,41769 ,41761 ]]),range ,sorted ,'1-'[::-1 ],dict ,~-347074842 -(9609975 ^339563490 ),~-(488929928 ^488929975 ),76509041 +701809815 +(381384252 -1159703068 ),~-(826269795 ^826269771 ),(220528104 ^608294749 )-(662198351 ^236810954 ),~-~-21 ,(840199252 ^293448293 )+(423243669 +-1017378225 ),list ,249489777 ^37735690 ^~-216081535 ,623972496 +-560031764 ^(624697595 ^653494408 ),640083529 -545766877 +(720499670 +-814816278 ),~-575608531 -(328760291 +246848239 ),895302803 ^264134460 ^~-987980691 ,dict ,'etad'[::-1 ],len ,(637872181 ^877253960 )-~-307035493 ,964554478 +-293102041 -(274222986 ^945668766 ),~(969701321 +-969701364 ),~-(124058437 ^124058474 ),int ,~-(611995495 ^611995509 ),~-94576568 ^(15960608 ^89167242 ),198614869 ^794047883 ^(837989135 ^359668188 ),296597985 +-26275777 ^663658509 +-393336332 ,(602351190 ^604843090 )+-~-132778457 ,277787080 ^255937176 ^(988941928 ^624817500 ),~-(905050477 ^905050421 ),~-481038092 ^428392674 --52645414 ,315250860 ^399799170 ^(215767363 ^163738209 ),int ,8739838 --13733537 ^230306198 +-207832798 ,~-(862951105 ^862951148 ),862157736 ^872031218 ^645222068 +-635172461 ,~(843543669 +-843543674 ),~-382144037 ^603199606 -221055544 ,~(431663941 +-431664003 ),~-21311637 ^(567970382 ^547338959 ),(660598346 ^852762273 )+-(430524027 ^203601590 ),844578294 ^326238411 ^725950536 -169861842 ,89852390 +-65486883 ^498522184 +-474156631 ,range ,826444002 -542001703 ^351867674 +-67425402 ,codecs .decode ('fgnghf','rot13'),-~-(744671436 ^744671438 ),codecs .decode (b'6d6f7669655f636f6465','hex').decode ('utf-8'),~-(714411034 ^714411078 ),''.join ([chr (ABN ^32669 )for ABN in [32757 ,32760 ,32764 ,32761 ,32760 ,32751 ]]),821656478 -321512951 ^(563390436 ^1012609607 ),764786066 ^188792816 ^(678302687 ^247142886 ),374686724 ^154690724 ^~-527245489 ,976477469 ^240045966 ^142019569 +738592418 ,~-(915980784 ^915980785 ),183162653 +122429043 +-(483914922 ^249627095 ),(180396280 ^669901389 )+-~-757940875 ,29778126 ^972750309 ^~-943496493 ,788565956 +31708550 ^(506878226 ^785529870 ),'detceted atad gnikoob tcilfnoC'[::-1 ],600510767 ^974311476 ^(438480009 ^66809301 ),len ,536397149 --439523256 ^(56335046 ^963692467 ),~-(258395745 ^258395750 ),~-(284854390 ^284854358 ),305369219 +-169030369 ^~-136338823 ,684458623 ^531880941 ^(419609970 ^779969790 ),(125401048 ^697068113 )-~-787815794 ,(524383476 ^1049438218 )-(897833860 -330792622 ),800602406 -689838603 ^904073410 +-793309633 ,bool (12 ),dict ,any ,584687241 ^825488735 ^(537543336 ^870328684 ),585359084 --218326225 ^~-803685262 ,isinstance ,338838468 ^962493466 ^(208333303 ^554096142 ),331140395 ^666103610 ^~-873406994 ,codecs .decode (b'686561646572','hex').decode ('utf-8'),~(780651971 -780652013 ),''.join ([chr (ABO ^20747 )for ABO in [20841 ,20842 ,20856 ,20846 ,20779 ,20845 ,20834 ,20839 ,20846 ,20779 ,20837 ,20842 ,20838 ,20846 ]]),(249718146 ^559689670 )-(78441424 +722558533 ),list ,codecs .decode ('zbivr_gvzr_raq','rot13'),(652750796 ^214612057 )+(55790398 -762700463 ),(612151241 ^793020805 )+-(399569351 ^485021682 ),213416232 +622409100 +(385286371 +-1221111701 ),len ,~(31220069 -31220143 ),set ,''.join ([chr (ABP ^64406 )for ABP in [64469 ,64505 ,64504 ,64496 ,64506 ,64511 ,64501 ,64482 ,64438 ,64485 ,64501 ,64510 ,64499 ,64498 ,64483 ,64506 ,64499 ,64438 ,64498 ,64499 ,64482 ,64499 ,64501 ,64482 ,64499 ,64498 ,64439 ]]),list ,len ,(82527826 ^34380881 )+-(277820323 ^375974402 ),537401514 ^1029842526 ^228125577 +265376605 ,570868247 +243826865 ^~-814695119 ,int ,605319421 ^706807171 ^548674458 -310289976 ,range ,794459949 ^430789790 ^(428757339 ^796490378 ),38086053 --343974794 ^~-382060878 ,285865976 +16677762 ^233215523 +69328181 ,990934966 -329659528 ^(552215237 ^125854184 ),~-~-15 ,~-533427181 +-(886028024 ^721732890 ),not 1 ,(850440997 ^981424607 )-(868899309 +-721055477 ),~(536680084 +-536680134 ),694394110 -534259868 ^(540758683 ^699410088 ),625797359 +-516108235 -(657448765 ^564553715 ),(439653899 ^360403792 )-(364286049 ^452547897 ),159434010 +739764117 ^388947981 +510250152 ,961457344 +-232546446 ^(875181195 ^525891768 ),dict ,~-585954222 -(648795024 ^71770167 ),bool (22 ),734610518 ^713614875 ^818790772 +-797712149 ,codecs .decode (b'6d6f7669655f74696d655f7374617274','hex').decode ('utf-8'),38232084 ^490222542 ^220099563 +308338658 ,~(209064097 -209064100 ),70 >=19 ,226893989 -123179897 ^~-103714110 ,237808319 ^626043420 ^453669607 --275877299 ,~-(258716446 ^258716417 ),673239250 +-296760930 ^~-376478276 ,bool (44 ),codecs .decode ('onfr svyr anzr','rot13'),dict ,774874084 ^885491079 ^(633083963 ^1062485581 ),822120639 -81961778 ^(534684330 ^868437816 ),-~-(377080782 ^377080780 ),~-~-43 ,~-(609861382 ^609861388 ),~-~-20 ,~-131381018 +(347788927 -479169920 ),~-(227190192 ^227190196 ),~-145743864 ^~-145743826 ,list ,346012817 --442796490 +(607328997 +-1396138263 ),(262852348 ^1006141333 )+-(626032432 ^285396492 ),367485981 +-179694262 +(946219548 +-1134011217 ),419693897 +360907272 +-(984565832 ^338185997 ),~-(47450846 ^47450783 ),(814732837 ^68929546 )-(623146955 ^296774109 ),513975657 -209230699 ^570532451 -265787525 ,'!detceted eludehcs tcilfnoC'[::-1 ],''.join ([chr (ABQ ^16373 )for ABQ in [16324 ]]),9540507 +304991122 -(433730230 +-119198661 ),~-(337226078 ^337226091 ),919154811 ^323259254 ^(82509835 ^560380726 ),586571495 ^541896227 ^(117724502 ^96380345 ),(888104949 ^130438972 )+-(966386407 ^179360325 ),~-(731245541 ^731245501 ),~-(348420820 ^348420845 ),tuple ,~-(569449049 ^569448965 ),163390020 --762355065 ^~-925745068 ,~-(693188503 ^693188594 ),523368913 --8430531 ^~-531799484 ,~(613790127 -613790149 ),-(675245408 ^311124845 ^(777212186 ^350707478 )),~(669116911 +-669116947 ),not 3 ,~-493237818 -(863041080 +-369803336 ),463183327 ^240501884 ^(276599260 ^95602768 ),20 >59 ,''.join ([chr (ABR ^22462 )for ABR in [22492 ,22495 ,22477 ,22491 ,22430 ,22488 ,22487 ,22482 ,22491 ,22430 ,22480 ,22495 ,22483 ,22491 ]]),791334688 --55761070 +(700394662 -1547490415 ),747277386 ^33703918 ^(262573586 ^556680685 ),404518163 +-365893140 -(470986430 +-432361427 ),242150861 --442053637 ^676141493 --8062940 ,~-195916441 ^(549352059 ^722665670 ),583327709 --25224900 ^(844157283 ^370481090 ),260968288 --350506756 +-~-611475003 ,316808903 ^675197616 ^(627425971 ^532246215 ),int ,481688212 ^215376968 ^(225885748 ^487923940 ),(64913864 ^923135040 )+(423085017 -1309880649 ),~(213090149 -213090199 ),~-461492582 ^(644588200 ^1038775268 ),(208777008 ^425939789 )+(73956051 -427521862 ),4558328 ^812116340 ^~-807560380 ,171602460 +730471869 -(597945827 +304128416 ),~-494734508 +-(574829315 ^1061044082 ),(406674562 ^811252271 )-(1830558 ^679217161 ),747596697 -259275756 +(774237196 -1262558118 ),~-(810685993 ^810685995 ),313073887 ^271740082 ^479779507 -436047461 ,~-(325102020 ^325101952 ),~(654348525 -654348534 ),957417665 +-477025021 +(23555760 +-503948366 ),556275653 ^975492727 ^(685326188 ^869662420 ),codecs .decode ('zbivr_gvzr_fgneg','rot13'),880987371 ^801878843 ^~-457801693 ,619544059 -138066971 -(457618249 ^133460631 ),~(168488845 -168488873 ),~-526614452 ^(184994341 ^342209976 ),(408885503 ^199350800 )+-(712826098 ^969023002 ),427872972 +-235064932 ^~-192808034 ,738788805 ^528640281 ^143409014 --721366361 ,~-37627974 ^883830556 +-846202624 ,bool (5 ),~-~-44 ,705365691 +91615580 ^(620228024 ^192353699 ),''.join ([chr (ABS ^62597 )for ABS in [62701 ,62688 ,62692 ,62689 ,62688 ,62711 ]]),438603573 ^479266472 ^786567098 +-674006557 ,~-212123117 ^(459205485 ^402282164 ),348047838 --323798228 ^~-671846053 ,654678648 ^129964594 ^289483619 --259609765 ,10026109 ^886348865 ^(963775191 ^222194368 ),987925829 +-124354203 ^(770220431 ^512864051 ),list ,444093723 ^161341512 ^(841908167 ^567003778 ),~(132381970 +-132382044 ),int ,95606197 ^584311366 ^(244569668 ^703783322 ),codecs .decode ('**','rot13'),~-776484439 ^758147789 --18336583 ,~(559320170 +-559320211 ),~-(337456456 ^337456473 ),298123600 ^82926051 ^(643524847 ^862924920 ),list ,225534733 ^367886341 ^(616753640 ^1012796075 ))

def PE (PG ):
    return True 

def PF (PG ):
    return PG 
PH =lambda PJ :True 
PI =lambda PJ :PJ 

class PK :

    @staticmethod 
    def PL (PN ):
        return True 

    @staticmethod 
    def PM (PN ):
        return PN 

def OB (OC ):
    KA =ddf .MOVIE_LIST_DICTIONARY 
    KB =ddf .MOVIE_SEATS_DICTIONARY 
    KC =ddf .CINEMA_DEVICE_DICTIONARY 
    KD =ddf .CINEMA_SEATS_DICTIONARY 
    KE =ddf .BOOKING_DATA_DICTIONARY 
    KF =ddf .CUSTOMER_DATA_DICTIONARY 
    if not OC :
        KG ,KH =BN (movie_list_dict =KA )
        if not KG :
            raise ValueError (OD ,KH )
    KI =EZ (list_dict =KA ,PK_location =OE ,FK_location =OF )
    GA (movie_list_dict =KA ,movie_seats_dict =KB ,cinema_device_dict =KC ,cinema_seats_dict =KD ,mc_code_dict =KI )
    KI =EZ (list_dict =KA ,PK_location =OE ,FK_location =OF )
    KJ ,KK =DU (movie_seats_dict =KB ,booking_data_dict =KE ,cinema_seats_dict =KD ,mc_code_dict =KI )
    if not OC :
        if not KJ :
            raise ValueError (OG ,KK )
    ccsf .DV (list_csv =KF [OH ],list_dictionary_cache =KF )

def FZ (skip_conflict_test :bool =False )->None :
    return OB (skip_conflict_test )

def OI (OJ ,OK ,OL ,OM ,ON ,OO ,OP ,OQ ):
    KL =OL [OR ]
    KM =OP [OR ]
    KN :OS =ccsf .FD (dictionary_cache =OL )
    KO :OT =[]
    EN (movie_seats_dict =OP ,cinema_seats_dict =OO ,mc_code_dict =OM )
    for OU in [OV ]:
        for OW in OX (OY ,OZ ):
            for PA in OX (PB ,PC ,PD ):
                while ((PH (PO )and PE (PP ))and (PQ !=PR or not PE (PS )))and (PT ==PU and PK .PL (OV )or (not PV or PE (PW ))):
                    for PX in [PY ]:
                        for KP in KN :
                            if ((PZ >QA or QB >QC )or (QD and PH (PR )))and (PE (PV )and (not PH (QE ))or (PH (PR )and QF >QG )):
                                KQ :OS =CT (booking_data_array =KP ,booking_id_location =OQ ,movie_code_location =ON ,x_seats_location =OK ,y_seats_location =OJ )
                                KR :OT =ccsf .FH (cache_dictionary =OP ,code =KQ [QH ])
                                KS ,KT =BQ (current_movie_seats =KR ,bkid_mvcode_x_y_list =KQ ,booking_data_dict =OL ,movie_seats_dict =OP )
                                if not KS :
                                    msf .EH (movie_seat_list =KR ,x_axis =KQ [OF ],y_axis =KQ [PW ],target_number =QH )
                                    ccsf .FO (seats_dictionary =OP ,mt_code_dictionary =OM ,code_to_update =KQ [QI ],seats_data_to_add =KR )
                                else :
                                    KO .append (KT )
                    break 
    ccsf .DV (list_csv =KL ,list_dictionary_cache =OL )
    ccsf .FP (seats_csv =KM ,seats_dictionary_cache =OP ,mt_code_dictionary_cache =OM )
    if KO :
        return (QJ ,KO )
    else :
        return (QK ,[])

def DU (movie_seats_dict ,booking_data_dict ,cinema_seats_dict ,mc_code_dict ,booking_id_location :int =0 ,book_movie_code_location :int =2 ,book_x_seats_location :int =5 ,book_y_seats_location :int =6 )->tuple [bool ,list ]:
    return OI (book_y_seats_location ,book_x_seats_location ,booking_data_dict ,mc_code_dict ,book_movie_code_location ,cinema_seats_dict ,movie_seats_dict ,booking_id_location )

def QL (QM ,QN ,QO ):
    if ((not PK .PL (QP )or QQ >=QR )or (PE (QS )and (not PE (OF ))))or (PK .PL (QT )and (not QU )or (QV !=QW and QX !=QY )):
        for KU ,KV in QN .items ():
            if (QZ >RA and PH (RB )or (PE (RC )and (not PK .PL (PC ))))and (not PK .PL (PB )and PK .PL (QG )or (PH (QJ )and PH (QA ))):
                EQ (movie_code =KU ,cinema_code =KV .upper (),movie_seats_dict =QM ,cinema_seats_dict =QO ,mc_code_dict =QN )

def EN (movie_seats_dict :dict ,cinema_seats_dict :dict ,mc_code_dict :dict )->None :
    return QL (movie_seats_dict ,mc_code_dict ,cinema_seats_dict )

def RD (RE ,RF ,RG ,RH ,RI ):
    KW :RJ =ccsf .FH (cache_dictionary =RI ,code =RF .upper ())
    KX :RJ =[KY [:]for KY in KW ]
    ccsf .FO (seats_dictionary =RE ,mt_code_dictionary =RG ,code_to_update =RH ,seats_data_to_add =KX )

def EQ (movie_code :str ,cinema_code :str ,movie_seats_dict :dict ,cinema_seats_dict :dict ,mc_code_dict :dict )->None :
    return RD (movie_seats_dict ,cinema_code ,mc_code_dict ,movie_code ,cinema_seats_dict )

def RK (RL ,RM ,RN ,RO ,RP ):
    if RQ ((RR (KZ ,(OT ,RS ))for KZ in RL )):
        raise TypeError (f'booking_data_array: {RL } must be a array (no 2d list allowed)')
    LA :OT =[]
    LA .append (RL [RM ])
    LA .append (RL [RO ])
    LA .append (RT (RL [RN ]))
    LA .append (RU (RL [RP ]))
    return LA 

def CT (booking_data_array :list ,booking_id_location :int ,movie_code_location :int ,x_seats_location :int ,y_seats_location :int )->list :
    return RK (booking_data_array ,booking_id_location ,x_seats_location ,movie_code_location ,y_seats_location )

def RV (RW ,RX ):
    LB :OT =[]
    for LC in RX :
        if (RY ==RZ and PE (QT ))and (not PE (SA )or PE (SB ))or (not SC and SD or (not PH (SE )or not RZ )):
            if LC not in RW :
                LB .append (LC )
    return LB 

def EC (main_list :list ,compared_list :list )->list :
    return RV (compared_list ,main_list )

def SF (SG ,SH ,SI ,SJ ,SK ):
    LD =SJ [PP ]
    LE =SK [SL ]
    LF =SI [OR ]
    LG :SM =fu .DM (header_list =SJ [SN ])
    LH :OS =ccsf .FD (dictionary_cache =SJ )
    LI :SO =fu .CV (dictionary_cache =SI )
    LJ :OT =ccsf .FR (seats_cache =SG )
    LK :OS =idg .BL (code_list =LH ,code_location =PT ,number_of_prefix =PO )
    LL :RJ =ccsf .FR (seats_cache =SK )
    LM :OS =EC (main_list =LL ,compared_list =LK )
    LN :SO =EC (main_list =LI ,compared_list =LJ )
    LO :RJ =EC (main_list =LK ,compared_list =LL )
    LP :RJ =EC (main_list =LJ ,compared_list =LI )
    AG (seats_list_mismatched =LM ,device_list_mismatched =LN ,movie_seats_dict =SK ,cinema_device_dict =SI )
    AF (movie_list_dict =SJ ,list_seats_mismatched =LO ,list_device_mismatched =LP ,movie_seats_dict =SK ,template_seats_dict =SG ,mt_code_dict =SH ,cinema_device_dict =SI )
    ccsf .DV (list_csv =LD ,list_dictionary_cache =SJ )
    ccsf .FP (seats_csv =LE ,seats_dictionary_cache =SK ,mt_code_dictionary_cache =SH )
    ccsf .DV (list_csv =LF ,list_dictionary_cache =SI )

def GA (movie_list_dict :dict ,movie_seats_dict :dict ,cinema_device_dict :dict ,cinema_seats_dict :dict ,mc_code_dict :dict )->None :
    return SF (cinema_seats_dict ,mc_code_dict ,cinema_device_dict ,movie_list_dict ,movie_seats_dict )

def SP (SQ ,SR ,SS ,ST ):
    if ST :
        for LQ in ST :
            if ((not PH (SU )or SV >=SW )or (not PH (SX )or not PK .PL (SY )))or (not PK .PL (SZ )and PH (PS )or (PH (TA )and TB )):
                ccsf .CC (dictionary =SQ ,key_to_delete =LQ )
    if SS :
        for LR in SS :
            if ((PK .PL (SB )or not TC )and (PK .PL (TD )and TE <=TF ))and ((OF and TG )and (not PE (TH )or PE (RZ ))):
                ccsf .CC (dictionary =SR ,key_to_delete =LR )

def AG (seats_list_mismatched :list ,device_list_mismatched :list ,movie_seats_dict :dict ,cinema_device_dict :dict )->None :
    return SP (movie_seats_dict ,cinema_device_dict ,device_list_mismatched ,seats_list_mismatched )

def TI (TJ ,TK ,TL ,TM ,TN ,TO ,TP ):
    if TL :
        for TQ in TR (RZ ,QB ,TS ):
            for LS in TL :
                if (PK .PL (TT )and TU <SA or (TV >TW or PK .PL (PY )))and (PE (QB )and PK .PL (TX )or (not PH (TD )and OV <TY )):
                    LT =TP [LS ][TZ ].upper ()
                    EQ (movie_code =LS ,cinema_code =LT ,movie_seats_dict =TM ,mc_code_dict =TN ,cinema_seats_dict =TO )
    if TK :
        LU =TJ .get (UA )
        LV =fu .DQ (any_dimension_list =LU ,keyword =UB )
        for LT in TK :
            if (QC <=UC and QD or (SZ and (not PW )))or (PH (UD )and UE !=UF or (TW ==UG or not PK .PL (OG ))):
                LW :RJ =ccsf .FD (dictionary_cache =TJ )
                LX :UH =fu .BT (LT ,*(PT for LY in TR (LV )))
                ccsf .DX (dictionary =TJ ,list_to_add =LX )

def AF (list_seats_mismatched :list ,list_device_mismatched :list ,movie_seats_dict :dict ,template_seats_dict :dict ,mt_code_dict :dict ,cinema_device_dict :dict ,movie_list_dict :dict )->None :
    return TI (cinema_device_dict ,list_device_mismatched ,list_seats_mismatched ,movie_seats_dict ,mt_code_dict ,template_seats_dict ,movie_list_dict )

def UI (UJ ,UK ,UL ,UM ):
    LZ =msf .ES (movie_seats =UM ,x_axis =UL [OF ],y_axis =UL [UN ])
    if LZ ==UO or LZ ==UP :
        return (UQ ,UL [OE ])
    return (QJ ,UR )

def BQ (current_movie_seats :list ,bkid_mvcode_x_y_list :list ,booking_data_dict :dict ,movie_seats_dict :dict )->tuple [bool ,str ]:
    return UI (booking_data_dict ,movie_seats_dict ,bkid_mvcode_x_y_list ,current_movie_seats )

def US (UT ):
    MA =FD (dictionary_cache =UT ,code =SN ,header_insert =QJ )
    MB =FD (dictionary_cache =UT )
    MC =fu .DM (header_list =MA )
    MD ,ME =_conflict_detect_preliminary (header_dict =MC ,movie_list =MB )
    if not MD :
        return (UU ,[])
    MF ,MG =_conflict_detect_meticulous (header_dict =MC ,conflict_dict =ME ,movie_list_dict =UT )
    if not MF :
        return (UU ,[])
    return (QJ ,MG )

def BN (movie_list_dict :dict )->tuple [bool ,list ]:
    return US (movie_list_dict )

def UV (UW ,UX ):
    MH :UY =UX [UZ ]
    MI :RT =UX [VA ]
    MJ :UY =UX [VB ]
    MK :SM ={}
    ML :VC ={}
    for MM in UW :
        if ((not QQ or PH (UR ))or (PB >=VD and VE ))and ((PH (SD )or VF <=VG )and (PK .PL (TV )or not PE (VH ))):
            MN =MM [MH ]
            MO =MM [MI ]
            MP =MM [MJ ]
            if not MK .get (MO +MP ):
                MK .update ({MO +MP :[]})
            MK [MO +MP ].append (MN )
    for VI in TR (TC ,VJ ):
        for VK in TR (PC ,UN ,VL ):
            for MQ ,MR in MK .items ():
                if ((VM <VN or VO )and (PH (TC )and VO ))and ((not PK .PL (VP )or not SY )or (VQ !=VR and PE (VS ))):
                    if VT (MR )>TZ :
                        ML .update ({MQ :MK [MQ ]})
    if not ML :
        return (VU ,{})
    return (QK ,ML )

def _conflict_detect_preliminary (header_dict :dict ,movie_list :list )->tuple [bool ,dict ]:
    return UV (movie_list ,header_dict )

def VV (VW ,VX ,VY ):
    MS :RU =VY [VZ ]-QI 
    MT :WA =VY [WB ]-WC 
    MU :WD =[]
    MV :UH =[]
    for MW in VW .values ():
        if ((not PE (WE )or not QY )or (WF ==SC and QD !=WG ))and ((SW <=WH or not PK .PL (SW ))or (WI and PE (WJ ))):
            MX :UH =[]
            for MY in MW :
                if ((WK <=QI or PE (WL ))and (not WM or PK .PL (WN )))and ((WO <WP or WQ <WR )or (not SB or not PE (WS ))):
                    MZ :UH =[]
                    MZ .append (MY )
                    MZ .append (fu .GC (VX .get (MY )[MS ]))
                    MZ .append (fu .GC (VX .get (MY )[MT ]))
                    MX .append (MZ )
            MU .append (WT (MX ,key =lambda movie :movie [TZ ]))
    for NA in MU :
        if (WU >SD and (not WV )or (PZ <WW and PH (PR )))and ((OF or not PH (QB ))or (PE (WX )and WJ >=WY )):
            NB :WZ =WZ ()
            NC :OS =[]
            if (PE (XA )or UD <XB )and (PH (XC )or not PK .PL (XD ))or (not PK .PL (XE )and PH (XF )or (not WL or not XG )):
                for ND in TR (XH (NA )-QH ):
                    if ((PK .PL (XI )or not PE (XJ ))or (TB !=XK or not XL ))or (QF !=XM and (not PE (OR ))or (not PK .PL (UD )or not PH (XN ))):
                        if BO (minuteAEND =NA [ND ][XO ],minuteBSTART =NA [ND +QI ][QH ]):
                            continue 
                        NB .add (NA [ND ][OE ])
                        NB .add (NA [ND +TZ ][PT ])
            for ND in OX (XP (NA )):
                if ((not PK .PL (PB )or PE (QC ))or (not PH (XQ )or not PK .PL (XD )))and ((not PH (QB )or not QG )or (PE (XR )or XS ==XT )):
                    if not NB :
                        break 
                    if NA [ND ][XU ]in NB :
                        NC .append (f'**{NA [ND ][0 ]}**')
                        continue 
                    NC .append (NA [ND ][PT ])
            if NB :
                MV .append (NC )
    if not MV :
        return (QJ ,[])
    return (XV ,MV )

def _conflict_detect_meticulous (header_dict :dict ,conflict_dict :dict ,movie_list_dict :dict )->tuple [bool ,list ]:
    return VV (conflict_dict ,movie_list_dict ,header_dict )

def XW (XX ,XY ):
    if XX <=XY :
        return XZ 
    return QJ 

def BO (minuteAEND :int ,minuteBSTART :int )->bool :
    return XW (minuteAEND ,minuteBSTART )

def YA (YB ,YC ):
    NE :YD =fu .DM (ccsf .FD (dictionary_cache =YC ,code =UA ,header_insert =YE ))
    NF :YF =NE [YG ]-QI 
    NG :YH =NE [WB ]-TZ 
    NH :SM ={}
    NI =fu .DR (any_dimension_list =YB ,keyword =YI )
    NI =fu .EV (NI )
    for NJ in NI :
        if ((PK .PL (RA )and YJ )and (YK and PH (YL )))and ((PE (TU )or not YM )and (VE and YN )):
            while (PH (YO )and YP or (not XK or WS >YQ ))and ((not PK .PL (YR )or not XF )or (XK or not PE (YS ))):
                for NK in NJ :
                    if ((not YS or YT ==YU )or (SV <=YV and WH ))and ((not YW or PK .PL (VS ))or (YP >YX or not XI )):
                        NH .update ({NK :[YC .get (NK )[NF ]]})
                        NH [NK ].append (YC .get (NK )[NG ])
                break 
    NL :YY =CB (time_dict =NH ,convert_func =fu .GC )
    NM ,NN =BP (conflict_minute_dict =NL ,schedule_list_strip =NI )
    NO :YY =CB (time_dict =NM ,convert_func =fu .ED )
    while ((not WV or not YZ )or (not QB and QS <XR ))or ((ZA >=ZB and ZC >=VN )and (PE (ZD )and PK .PL (VH ))):
        if ((ZE <ZF or not PK .PL (OV ))and (YL and PE (SX )))and (PH (YW )and (not PK .PL (PR ))or (not PE (ZG )or PE (ZH ))):
            while (YK >ZI or XJ )and (not PK .PL (ZJ )or not PE (TG ))or ((ZK !=YJ and WL !=SU )and (ZL >=ZD and WN )):
                for NP ,NQ in NO .items ():
                    if (UE ==PU and ZJ or (ZM ==ZN or not PK .PL (ZO )))and (PB and PE (UO )or (ZP <=RA and ZQ >=TG )):
                        YC [NP ][NF ]=NQ [ZR ]
                        YC [NP ][NG ]=NQ [QH ]
                break 
        break 
    if NN :
        return (VU ,NN )
    return (ZS ,[])

def FM (schedule_conflict_list :list ,movie_list_dict :dict =None )->tuple [bool ,list ]:
    return YA (schedule_conflict_list ,movie_list_dict )

def ZT (ZU ,ZV ):
    NR :ZW =ZU .copy ()
    NS :SO =[]
    while ((not ZX or not PK .PL (SV ))or (OZ !=VN or not PK .PL (SB )))or ((PH (WJ )or not VN )and (ZP <ZY or WH !=ZZ )):
        if ((PK .PL (YW )or not YK )and (PE (AAA )and SA !=SD ))and (PK .PL (XC )and XL or (not PK .PL (QZ )or not PH (AAB ))):
            if ((not PK .PL (AAC )or PE (VS ))and (TV or not PH (ZY )))and (AAD >=AAE and PK .PL (AAF )or (PH (SV )and (not PK .PL (AAG )))):
                if ((not PE (VS )or not PK .PL (AAH ))or (PE (AAI )and PK .PL (PC )))or (AAJ and (not PH (TD ))or (PK .PL (QH )and QQ <=SD )):
                    for NT in ZV :
                        if ((not PE (ZA )or AAK !=QY )or (not QB and PK .PL (AAL )))or ((not TF and PE (OZ ))and (AAM and PH (VZ ))):
                            NU :YF =PT 
                            for NV in AAN (XH (NT )-WC ):
                                if ((not WV or ZF ==TB )or (RZ and PK .PL (WP )))and ((AAO >AAP or not PK .PL (AAQ ))or (AAE <AAR and TD >=AAS )):
                                    if not BO (minuteAEND =NR [NT [NV ]][WC ],minuteBSTART =NR [NT [NV +QI ]][AAT ]):
                                        NW =NR [NT [NV +WC ]][QH ]-NR [NT [NV +YZ ]][XU ]
                                        NR [NT [NV +AAU ]][PO ]=NR [NT [NV ]][WC ]
                                        NR [NT [NV +QI ]][WC ]=NR [NT [NV ]][YZ ]+NW 
                            NX :WA =AAV 
                            if NR [NT [-QI ]][YZ ]>=NX :
                                NU =NR [NT [-WC ]][QI ]-NX 
                                NR [NT [OE ]][PO ]-=NU 
                                NR [NT [PO ]][AAU ]-=NU 
                            if NR [NT [PO ]][PT ]<PO :
                                NS .append (NT )
                                continue 
                            for NV in TR (TZ ,AAW (NT )):
                                if ((not AAX or AAY <RY )or (AAZ and (not ABA )))or ((not PE (AAJ )or not PE (WG ))or (ABB <ABC or ABD <=OV )):
                                    NR [NT [NV ]][XU ]-=NU 
                                    NR [NT [NV ]][WC ]-=NU 
        break 
    return (NR ,NS )

def BP (conflict_minute_dict :dict ,schedule_list_strip :list )->tuple [dict ,list ]:
    return ZT (conflict_minute_dict ,schedule_list_strip )

def ABE (ABF ,ABG ):
    NY :YD =ABG .copy ()
    for NZ ,OA in NY .items ():
        if (not PK .PL (ABH )and PH (AAA )or (PH (ABI )and PH (ZH )))and (ABJ and AAA or (XO >=ZP and PK .PL (ABK ))):
            NY [NZ ]=[ABF (OA [PT ]),ABF (OA [QI ])]
    return NY 

def CB (time_dict :dict ,convert_func )->dict :
    return ABE (convert_func ,time_dict )