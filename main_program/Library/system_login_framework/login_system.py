import random 
import os 
from main_program .Library .FL .BK import BK 
import codecs 
EUF ,EUS ,EUZ ,EPM ,ERW ,ELQ ,EUA ,ESZ ,ELW ,EUD ,EWG ,EQR ,EWU ,ENA ,ESW ,ELI ,ETT ,ELY ,EOX ,ELM ,EQI ,EMP ,EPV ,EOL ,ELT ,EWY ,EKZ ,EMM ,EWH ,EQT ,ERG ,ETZ ,EPF ,EXC ,EPK ,ETL ,EXA ,ELA ,ERT ,EUH ,ESE ,EMA ,EVM ,EVG ,ENX ,EQG ,ERR ,EMZ ,EOM ,ESJ ,ERE ,ERO ,EUI ,ENH ,EQZ ,EVU ,EPN ,EVN ,EUB ,ENI ,EVH ,ENC ,ERP ,EUO ,EQD ,EPX ,ERZ ,EPT ,ENO ,ELZ ,EON ,EMT ,EWS ,EQN ,ETO ,ESQ ,ETR ,EQQ ,ERV ,ERD ,EVT ,ENE ,ESL ,EQK ,END ,EVP ,EUE ,EVL ,EPS ,EVX ,ERY ,ERX ,EVS ,EST ,EVC ,ERC ,ETV ,ENY ,EUC ,ENG ,EWV ,EPP ,EWX ,EOS ,EWF ,ENS ,ETU ,ELL ,EVA ,EMB ,EME ,ETN ,EWA ,EVY ,ESA ,ELR ,ELD ,EPW ,ENN ,EQL ,ESY ,EPR ,EWR ,EOU ,ELX ,EQF ,EPH ,ESF ,ELS ,EUX ,EOZ ,EPY ,EPU ,ENV ,EPL ,ESC ,ESR ,EVV ,ESG ,EPI ,EMY ,EXB ,EVO ,ESH ,EOI ,EUY ,ESX ,ESV ,EOT ,ETX ,ETQ ,EOV ,EPA ,ETB ,EQJ ,ERH ,ENT ,EQO ,EWW ,ETD ,EMO ,EMN ,ERF ,ETA ,ESI ,EVJ ,EPG ,EXF ,ERS ,ETC ,ESD ,ELU ,EMS ,ESB ,EQS ,ETM ,EMR ,EXE ,ERA ,ETI ,EPJ ,EXD ,ENJ ,ENZ ,ETW ,EUU ,ELF ,EUT ,ELE ,ENM ,EOY ,EVE ,ENB ,EPQ ,ENW ,ENP ,EVB ,EQH ,EMW ,EQX ,EMQ ,EQE ,ERN ,EUV ,ETS ,EWC ,EVI ,EWD ,ESM ,EQY ,EMX ,EUP ,EWT ,EOW ,EWE ,EUW ,ENU ,EOA ,ETK ,EVK ,ENK ,EWZ ,EMD ,ENF ,EKY ,ESS ,EVZ ,ETE ,ETP ,EVQ ,ERL ,EQV ,ERQ ,EUN ,EWB ,ENL ,ENQ ,ERB ,EVR ,EQM ,ETY ,ERU ,EOR ,ERM ,ELK ,EMV ,ESK ,ENR ,EUG ,ESU ,ETJ ,EPO ,ELV ,EQP =((744275994 ^43558721 )-(747115758 ^38564775 ),bool (42 ),input ,789245636 ^710978575 ^857647164 +-766797144 ,80785171 ^499625021 ^161634698 +259303901 ,489745175 ^36935972 ^425409208 --94910317 ,'\n:eman ruoy retne esaelP'[::-1 ],range ,743782376 +-205049048 ^705516966 +-166783603 ,666293483 -500361110 ^(610353458 ^763538545 ),codecs .decode ('cyrnfr vachg lbhe ebyr ol ahzore\n','rot13'),338137552 ^951715966 ^(338925876 ^950927539 ),''.join ([chr (EXG ^9072 )for EXG in [8996 ,8984 ,8977 ,8990 ,8987 ,9040 ,8969 ,8991 ,8965 ,9040 ,8982 ,8991 ,8962 ,9040 ,8965 ,8963 ,8985 ,8990 ,8983 ,9040 ,8964 ,8984 ,8985 ,8963 ,9040 ,8963 ,8969 ,8963 ,8964 ,8981 ,8989 ]]),14347031 +136530599 -(721683544 ^603599336 ),970906424 ^722070774 ^~-316094417 ,'\n'[::-1 ],~-~-97 ,926453299 ^408017650 ^470091028 +325341104 ,~-313964191 ^761285367 +-447321151 ,(606228560 ^601782329 )-(812184324 -678218400 ),(405732596 ^311220840 )+-(391463181 ^502753172 ),(30234891 ^559964884 )-(658303005 ^126997451 ),codecs .decode ('Grpuavpvna','rot13'),open ,581255818 ^1036948474 ^(888090211 ^730136345 ),''.join ([chr (EXH ^1399 )for EXH in [1332 ]]),''.join ([chr (EXI ^38881 )for EXI in [38863 ,38863 ]]),(100945282 ^804377831 )-(937709959 ^504481996 ),''.join ([chr (EXJ ^56071 )for EXJ in [56174 ,56169 ,56177 ,56166 ,56171 ,56174 ,56163 ,56103 ,56169 ,56178 ,56170 ,56165 ,56162 ,56181 ,56107 ,56103 ,56183 ,56171 ,56162 ,56166 ,56180 ,56162 ,56103 ,56179 ,56181 ,56190 ,56103 ,56166 ,56160 ,56166 ,56174 ,56169 ]]),~-339559414 ^(60011491 ^397340683 ),~-170441318 ^~-170441265 ,508930645 ^346811217 ^~-184434999 ,47 >93 ,None ,548119319 +310519353 ^(543277709 ^323750786 ),~-439442471 -(136682542 ^303349805 ),''.join ([chr (EXK ^46107 )for EXK in [46200 ,46190 ,46184 ,46191 ,46196 ,46198 ,46206 ,46185 ,46139 ,46185 ,46206 ,46204 ,46194 ,46184 ,46191 ,46206 ,46185 ,46139 ,46184 ,46190 ,46200 ,46200 ,46206 ,46184 ,46184 ]]),'ataD'[::-1 ],'^'[::-1 ],codecs .decode ('vachg cnffjbeq\n','rot13'),bool (20 ),~-623030738 +-~-623030717 ,~-(303139640 ^303139634 ),655786368 -351626377 ^71159858 +233000121 ,len ,(453271540 ^113331482 )-(913388089 ^733225189 ),''.join ([chr (EXL ^5361 )for EXL in [5333 ]]),49564656 --650456675 -(178832702 ^588365574 ),''.join ([chr (EXM ^25060 )for EXM in [24982 ]]),'!rettel esacreppu eno tsael ta niatnoc dluohs drowssaP'[::-1 ],~-(760698344 ^760698317 ),''.join ([chr (EXN ^64437 )for EXN in [64404 ]]),print ,(638508309 ^947753296 )+-(749058312 ^852948243 ),445817743 ^288957089 ^169863401 +25925702 ,codecs .decode ('ybtva snvyrq','rot13'),~-(319086390 ^319086352 ),codecs .decode (b'50617373776f72642073686f756c6420636f6e7461696e206174206c65617374206f6e65206e756d62657221','hex').decode ('utf-8'),~(4190608 -4190644 ),852665675 ^399821687 ^(516374760 ^1002516160 ),634984184 ^229996779 ^~-678194729 ,~(71620560 -71620600 ),codecs .decode ('@','rot13'),'M'[::-1 ],48 >=75 ,codecs .decode ('Gvpxrgvat Pyrex','rot13'),'!'[::-1 ],''.join ([chr (EXO ^30887 )for EXO in [30948 ,30926 ,30921 ,30914 ,30922 ,30918 ,30855 ,30954 ,30918 ,30921 ,30918 ,30912 ,30914 ,30933 ]]),~(575716513 +-575716566 ),349919343 --494608933 ^(236884849 ^1011411373 ),codecs .decode (',','rot13'),(770964848 ^705071646 )+(563234235 +-696761597 ),623908263 ^1002348613 ^777591720 +-264922661 ,150719411 --670331487 ^(427709928 ^697199576 ),input ,(62340350 ^766529378 )+-(513754989 ^815281166 ),print ,911983960 ^4428002 ^131216141 --776348320 ,codecs .decode ('*','rot13'),718289231 +-633298365 ^(738459933 ^689232588 ),print ,(312714765 ^286407978 )+-(577893310 ^566257823 ),codecs .decode ('Cnffjbeq fubhyq pbagnva ng yrnfg bar fcrpvny punenpgre!','rot13'),917817902 +-256519788 ^(15303586 ^662902911 ),93330028 ^76678222 ^228284565 -211368569 ,' :edoc noitacifirev'[::-1 ],(195289444 ^644258580 )-~-767916607 ,65 >41 ,''.join ([chr (EXP ^11908 )for EXP in [11977 ]]),'tixE .5\nremotsuC .4\nnaicinhceT .3\nreganam ameniC .2\nkrelC gnitekciT .1'[::-1 ],(513304143 ^380498812 )-(992944852 +-855215567 ),(655721572 ^566166148 )+(965396001 +-1077234941 ),'sseccus nigol'[::-1 ],431942293 +28839680 ^11164782 +449617226 ,codecs .decode ('cnffjbeq:\n','rot13'),160377354 ^552413621 ^(546544354 ^166828415 ),(252476401 ^952004627 )+-(638879545 ^296127728 ),len ,(890844729 ^983547857 )-(654211233 -393735911 ),188572776 ^146044046 ^(840214394 ^832419743 ),~(113839198 -113839203 ),330480466 --402391542 ^~-732872011 ,None ,''.join ([chr (EXQ ^21154 )for EXQ in [21205 ]]),int ,~-~-54 ,~-187904085 +-(48251198 ^164851406 ),548543867 ^906290953 ^(626604206 ^871351000 ),codecs .decode ('HfreVQ:\n','rot13'),''.join ([chr (EXR ^46890 )for EXR in [46854 ]]),~-(886930899 ^886930919 ),~-468790332 +(762189533 -1230979841 ),~-457460477 +-(247431981 ^368822780 ),~-429223780 ^(796031227 ^921114537 ),~-912683284 ^(857304605 ^92217135 ),974976886 -336506442 -(855772132 ^353125160 ),open ,codecs .decode ('X','rot13'),codecs .decode (b'61','hex').decode ('utf-8'),(509576745 ^399706759 )-(661572995 -501367008 ),~(748520243 -748520287 ),''.join ([chr (EXS ^41095 )for EXS in [41156 ,41202 ,41204 ,41203 ,41192 ,41194 ,41186 ,41205 ]]),26886842 ^995363670 ^(512334891 ^608687560 ),497842363 ^1061363183 ^~-586114389 ,676989212 ^754281795 ^~-78603389 ,'reganaM ameniC'[::-1 ],(116911613 ^796958321 )+-(244551513 ^669318199 ),codecs .decode (b'20','hex').decode ('utf-8'),(221853139 ^236576495 )+-(326873515 ^274422448 ),593188246 ^587630292 ^298715516 -292566583 ,int ,None ,codecs .decode (b'54','hex').decode ('utf-8'),codecs .decode (b'30','hex').decode ('utf-8'),96577076 --667948738 ^~-764525820 ,47 !=86 ,617782811 -380729999 ^(730083827 ^631575155 ),None ,'!ecaps niatnoc ton dluohs drowssaP'[::-1 ],437560566 +479873700 +(222639204 -1140073455 ),~-~-16 ,codecs .decode (b'696e76616c6964206e756d6265722c20706c656173652074727920616761696e','hex').decode ('utf-8'),print ,codecs .decode (b'50617373776f72642073686f756c6420636f6e7461696e206174206c65617374206f6e6520616c70686121','hex').decode ('utf-8'),codecs .decode ('n','rot13'),codecs .decode (b'706c65617365206c6f67696e','hex').decode ('utf-8'),(800341531 ^454757503 )-(796960582 +86936295 ),880404021 ^584609579 ^~-379685128 ,'000'[::-1 ],(386875541 ^851448027 )-(355151589 ^820273432 ),print ,len ,~-494518052 ^(359546040 ^135758746 ),(61985574 ^786805286 )+(966092277 +-1726596839 ),820051356 +-178576272 -(974042377 -332567309 ),(807911762 ^967002728 )-(700593583 ^541507222 ),chr ,934018827 ^292566552 ^(976823496 ^484634097 ),codecs .decode (b'706c6561736520696e707574206c6f67696e283129206f72207265676973746572283229206279206e756d6265720a','hex').decode ('utf-8'),~-572888467 ^744832341 -171943843 ,~-105568618 ^230301550 -124732914 ,codecs .decode ('e','rot13'),codecs .decode (b'','hex').decode ('utf-8'),len ,''.join ([chr (EXT ^23580 )for EXT in [23628 ,23677 ,23663 ,23663 ,23659 ,23667 ,23662 ,23672 ,23612 ,23663 ,23668 ,23667 ,23657 ,23664 ,23672 ,23612 ,23679 ,23667 ,23666 ,23656 ,23677 ,23669 ,23666 ,23612 ,23677 ,23656 ,23612 ,23664 ,23673 ,23677 ,23663 ,23656 ,23612 ,23667 ,23666 ,23673 ,23612 ,23666 ,23657 ,23665 ,23678 ,23673 ,23662 ,23613 ]]),~-563793108 +-(370865347 ^931149825 ),codecs .decode ('\n','rot13'),''.join ([chr (EXU ^22026 )for EXU in [22101 ,22101 ,22119 ,22123 ,22115 ,22116 ,22101 ,22101 ]]),codecs .decode (b'25','hex').decode ('utf-8'),~(185250680 -185250703 ),28 !=58 ,~(804581419 +-804581422 ),~-74172675 ^(452943891 ^513059088 ),405232170 -25239928 -(444928935 +-64936722 ),125519955 ^452483865 ^(31394100 ^475798115 ),257870994 --45214971 -(562084233 ^865075427 ),667032468 +-26692152 ^(946253963 ^508322260 ),codecs .decode ('vainyvq ahzore, cyrnfr gel ntnva','rot13'),len ,(690036606 ^691070560 )-~-1177871 ,763353645 --84607907 +-(600644322 ^289916750 ),126454299 +633255906 +(908656696 -1668366898 ),~-581501753 ^~-581501706 ,(65046113 ^125119452 )-(477948018 ^417940943 ),(776916271 ^62610360 )-(824838922 ^484416903 ),~(157970150 +-157970186 ),''.join ([chr (EXV ^62654 )for EXV in []]),(265459276 ^284978892 )-~-523171965 ,'r'[::-1 ],ord ,~-(908568719 ^908568739 ),range ,(626378124 ^527958610 )-(873598597 ^239061290 ),codecs .decode (b'43','hex').decode ('utf-8'),333127742 --453087208 +-(105405260 ^680848234 ),ord ,input ,~-155700338 +-(597120793 ^718314304 ),366965477 +140610323 ^641605965 -134030183 ,311689520 --468906884 ^(153491024 ^664855266 ),447362157 +-132658049 +-(684917402 ^974193246 ),(749869729 ^5647474 )+-(724210064 ^130983746 ),33 ==69 ,(148663800 ^1045177993 )-(725592220 --189833917 ),'5 > htgnel dna retcarahc laiceps eno ,rebmun eno ,rettel esacrewol eno ,rettel esacreppu eno edulcni tsum drowssap'[::-1 ],~-~-43 ,370373946 ^746068626 ^(896804359 ^253708682 ),965665488 +-320350100 ^140087051 --505228318 ,codecs .decode (b'64656620726571756972652863686172293a0a202020200a2020202048656c7065722066756e6374696f6e3a20636f756e742074797065206f662063686172616374657220286c6f7765722f75707065722f6e756d626572290a202020205570646174657320676c6f62616c20636f756e746572732e0a202020200a20202020676c6f62616c20636f756e745f6c6f7765722c20636f756e745f6e756d6265722c20636f756e745f75707065720a202020206c6f7765725f6c697374203d205b5d0a2020202075707065725f6c697374203d205b5d0a202020206e756d6265725f6c697374203d205b5d0a20202020666f72206920696e2072616e6765283632293a0a202020202020202069662069203c2032363a0a2020202020202020202020206c6f7765725f6c6973742e617070656e6428636872286f72642827612729202b206929290a2020202020202020656c6966203236203c3d2069203c2035323a0a20202020202020202020202075707065725f6c6973742e617070656e6428636872286f72642827412729202b2069202d20323629290a2020202020202020656c69662069203e3d2035323a0a2020202020202020202020206e756d6265725f6c6973742e617070656e6428636872286f72642827302729202b2069202d20353229290a202020206966206368617220696e206c6f7765725f6c6973743a0a2020202020202020636f756e745f6c6f776572202b3d20310a202020202020202072657475726e20547275650a20202020656c6966206368617220696e2075707065725f6c6973743a0a2020202020202020636f756e745f7570706572202b3d20310a202020202020202072657475726e204e6f6e650a20202020656c6966206368617220696e206e756d6265725f6c6973743a0a2020202020202020636f756e745f6e756d626572202b3d20310a202020202020202072657475726e20547275650a20202020656c73653a0a202020202020202072657475726e2046616c7365','hex').decode ('utf-8'),range ,~-(728726895 ^728726909 ),(792033594 ^724649136 )+-~-67386739 ,~-835242256 ^(382870997 ^656075981 ),(200841497 ^1008913929 )-(207273275 ^998304732 ),(845827879 ^136165482 )+(90510489 -1071451069 ),467422643 -237908580 ^572590750 +-343076663 ,ord ,~(407513488 -407513490 ),(360568734 ^1041020013 )-~-728851417 ,824766840 +-628799241 ^(793232494 ^619314692 ),948554708 +-615077616 -(10171129 +323305955 ),print ,971409592 -432379513 +(382786991 +-921817020 ),~-429492128 +-~-429492105 ,'..'[::-1 ],~-673065758 ^(713159676 ^44030182 ),~-971549760 -(220089365 ^888594485 ),codecs .decode ('Hfreanzr rkvfg!','rot13'),codecs .decode ('Cyrnfr ragre lbhe anzr:\n','rot13'),codecs .decode (b'706c6561736520656e74657220766572696669636174696f6e20436f64653a0a','hex').decode ('utf-8'),46 ==95 ,~-149886525 -(42772049 --107114476 ),codecs .decode (b'23','hex').decode ('utf-8'),660413665 ^11888418 ^(766443277 ^172393670 ),~(25220060 -25220147 ),chr ,codecs .decode (b'41','hex').decode ('utf-8'),860103084 ^955308460 ^(303386988 ^430025087 ),'niaga yrt esaelp ,rorre edoc noitacifirev'[::-1 ],~-~-65 ,127997989 ^560885665 ^~-651130766 ,codecs .decode (b'26','hex').decode ('utf-8'),open ,29 !=29 ,range ,~-644823023 ^(648766683 ^12866308 ),codecs .decode (b'50617373776f72642073686f756c6420636f6e7461696e206174206c65617374206f6e65206c6f77657263617365206c657474657221','hex').decode ('utf-8'),496989568 +-12880020 ^407925499 +76184059 ,403959906 ^755105392 ^85189330 --805186372 ,~-(328270822 ^328270830 ),codecs .decode ('j','rot13'),(533886316 ^168267904 )-(280760338 ^90830326 ),~(934075339 -934075345 ),140670193 +223745585 ^(303522838 ^128970535 ))

def ELN (ELP ):
    return True 

def ELO (ELP ):
    return ELP 
EMJ =lambda EML :True 
EMK =lambda EML :EML 

class EMF :

    @staticmethod 
    def EMG (EMI ):
        return True 

    @staticmethod 
    def EMH (EMI ):
        return EMI 

def EKW (EKX ):
    EIF =os .path .dirname (os .path .abspath (__file__ ))
    EIG =os .path .normpath (os .path .join (EIF ,EKY ,EKZ ,ELA ,EKX ))
    return EIG 

def get_data_directory (path ):
    return EKW (path )

def ELB (ELC ):
    with ELD (ELC ,ELE ,newline =ELF )as EIH :
        EIH .readline ()
        EII =EIH .read ().strip ()
        return EII 

def CX (path ):
    return ELB (path )

def ELG (ELH ):
    EIJ =CX (ELH )
    if not EIJ :
        return []
    EIK =EIJ .split (ELI )
    EIL =[]
    for ELJ in ELK (ELL ,ELM ):
        for EIM in EIK :
            if (ELQ and ELR >ELS )and (ELT <ELU or not ELV )or ((ELN (ELW )or not ELX )and (ELN (ELY )and ELZ >EMA )):
                EIN =EIM .strip ().split (EMB )
                for EMC in ELK (EMD ,EME ):
                    for EIO in EIN :
                        if (ELU <EMM and EMJ (EMN ))and (not ELN (EMO )or EMF .EMG (EMP ))or ((EMQ and (not EMJ (EMR )))and (EMF .EMG (EMS )and EMJ (EMT ))):
                            EIL .append (EIO )
    return EIL 

def DA (path ):
    return ELG (path )

def EMU ():
    EIP =[]
    EIQ =[]
    EIR =[]
    if (EMV and EMW >=EMX or (not EMY or not EMJ (EMZ )))or (ENA !=EMY and EMM or (not EMF .EMG (ENB )or not ENC )):
        for EIS in ELK (END ):
            if (EMF .EMG (ENE )and ENF >=ENE or (not EMJ (ENG )or not EMF .EMG (ENH )))and ((not ENI or EMF .EMG (EMP ))or (not EMJ (ENJ )or not ELN (ENK ))):
                if EIS <EMM :
                    EIP .append (ENL (ENM (ENN )+EIS ))
                elif EMM <=EIS <ENO :
                    EIQ .append (ENL (ENP (ENQ )+EIS -ENR ))
                elif EIS >=ENS :
                    EIR .append (ENT (ENU (ENV )+EIS -ENS ))
    EIT =random .randint (ENW ,ENX (EIP )-EMS )
    EIU =random .randint (ENW ,ENY (EIQ )-EMS )
    EIV =random .randint (ENZ ,ENX (EIR )-EOA )
    return EIP [EIT ]+EIQ [EIU ]+EIR [EIV ]

def CP ()->str :
    return EMU ()

def EOB (EOC ,EOD ,EOE ,EOF ,EOG ,EOH ):
    EIW =ELD (EOD ,EOI )
    if EOC :
        EIW .write (f'{EOF }{EOG :03d},{EOE },{EOH },0\n')
    else :
        EIW .write (f'{EOF }{EOG :03d},{EOE },{EOH }\n')
    EIW .close ()

def GO (path ,user_id ,name ,password ,role_prefix ,has_balance_column :bool =False ):
    return EOB (has_balance_column ,path ,name ,role_prefix ,user_id ,password )

def EOJ (EOK ):
    with EOL (EOK ,EOM )as EIX :
        EIY =EIX .readline ()
        return ENY (EIY .split (EON ))

def CW (path ):
    return EOJ (path )

def EOO (EOP ,EOQ ):
    if not os .path .exists (EOP ):
        with EOR (EOP ,EOS )as EIZ :
            pass 
            return EOT 
    EIZ =ELD (EOP ,ELE )
    EIZ .readline ()
    EJA =EIZ .read ().strip ()
    EIZ .close ()
    if EJA ==ELF :
        return EOT 
    else :
        EJB =EOU 
        EJC =CW (EOP )
        EJD =DA (EOP )
        for EJE in ELK (ENZ ,EOV (EJD ),EJC ):
            if ((ELN (ENI )and EOW )and (EMF .EMG (ENG )and EOX !=EOY ))and ((EMQ and EMJ (EOS ))and (EMV and ELN (END ))):
                EJF =EJD [EJE ]
                if EJF .startswith (EOQ ):
                    EJG =EOZ (EJF [EPA :])
                    if EJG >EJB :
                        EJB =EJG 
    return EJB +EOA 

def CJ (path ,prefix ):
    return EOO (path ,prefix )

def EPB (EPC ,EPD ,EPE ):
    EJH =CX (EPC )
    if EJH ==ELF :
        return EPF 
    else :
        EJI =EJH .split (EPG )
        for EJJ in EJI :
            if ((EMD and ELN (EPH ))and (not ELN (EPI )or ELN (EPJ )))and ((EPK <EPL or EPM )or (not EMF .EMG (EPN )and EMJ (EPO ))):
                EJK =EJJ .split (EON )
                EJL ,EJM ,EJN =(EJK [ENZ ],EJK [EOA ],EJK [EPP ])
                if (EJL ==EPE or EJM ==EPE )and EPD ==EJN :
                    if EJL .startswith (EPQ ):
                        return EPR 
                    elif EJL .startswith (EPS ):
                        return EPT 
                    elif EJL .startswith (EPU ):
                        return EPV 
                    elif EJL .startswith (EPW ):
                        return EPX 
        return EPY 

def BD (path ,name_or_id ,input_password ):
    return EPB (path ,input_password ,name_or_id )

def EPZ (EQA ,EQB ,EQC ):
    EJO =CX (EQB )
    if EJO ==ELF :
        return EQD 
    else :
        EJP =DA (EQB )
        EJQ =CW (EQB )
        while (EQE and (not EMF .EMG (EQF ))or (EQG and EQH >=EQI ))and ((not EMF .EMG (EQJ )or not EPI )or (EQK >=EQL or EMM >=EQM )):
            for EJR in ELK (EOU ,EOV (EJP ),EJQ ):
                if (not EQN or EMJ (EQO ))and (EMF .EMG (EOW )and EQP )or ((ELN (ENW )and ENG <EQQ )and (not EMF .EMG (EQR )and EQS ==EQT )):
                    if EQC ==EJP [EJR ]:
                        return EQA ==EJP [EJR +EPP ]
            else :
                for EQU in ELK (EMT ,EOY ,EQV ):
                    for EQW in (EQX ,):
                        for EJR in EQY (EQZ ,ERA (EJP ),EJQ ):
                            if ((ERB ==EQP and ELN (EMP ))and (ERC !=EMP and ERD >EMD ))and ((not ERE or not ELN (ERF ))or (EPM <=ERG and ENE <=ELS )):
                                if EQC ==EJP [EJR ]:
                                    return EQA ==EJP [EJR +ERH ]
                return EPF 
            break 

def AZ (path ,name_or_id ,password ):
    return EPZ (password ,path ,name_or_id )

def ERI (ERJ ,ERK ):
    if ENY (ERK )<ERJ :
        raise ValueError (f'Password length must not be less than {ERJ }')
    EJS ,EJT ,EJU ,EJV ,EJW =(EPF ,EQD ,ERL ,ERM ,ERN )
    EJX =[ERO ,ERP ,ERQ ,ERR ,ERS ,ERT ,ERU ,ERV ]
    for EJY in ERK :
        if ((EMJ (EPA )and ERW >ENI )and (ELN (EPN )and ELN (ERX )))and ((not ERY or EMF .EMG (ERZ ))and (ESA >ESB and EPH )):
            if EJY .isdigit ():
                EJV =ESC 
            if EJY .isupper ():
                EJT =ESC 
            if EJY .islower ():
                EJS =ESD 
            if EJY .isalpha ():
                EJU =ESE 
            if EJY in EJX :
                EJW =ESC 
            if EJY ==ESF :
                raise ValueError (ESG )
    if not EJU :
        raise ValueError (ESH )
    if not EJV :
        raise ValueError (ESI )
    if not EJT :
        raise ValueError (ESJ )
    if not EJS :
        raise ValueError (ESK )
    if not EJW :
        raise ValueError (ESL )

def BE (password ,num ):
    return ERI (num ,password )
ESM 

def ESN (ESO ,ESP ):
    EJZ =CW (ESP )
    EKA =DA (ESP )
    if (ESQ >=EQL or not ESR )and (ELN (ESS )or EST ==EQG )or ((ESU or not ESV )and (ESW >=ESX or EOY !=ESY )):
        for EKB in ESZ (ERH ,ETA (EKA ),EJZ ):
            if ((ENS <ETB or EST )and (ENI and EQI ))and (EMJ (ERQ )and (not EMF .EMG (ETC ))or (ETD and ELN (ESG ))):
                if ESO ==EKA [EKB ]:
                    raise ValueError (ETE )

def BG (new_name ,path ):
    return ESN (new_name ,path )

def ETF (ETG ,ETH ):
    while ESD :
        if (ETI ==EQJ and EMJ (ETJ )or (not ELN (ELV )or not ELN (EPI )))and ((ETK <ENK or ETL !=ETM )or (ENC or not ELN (ETN ))):
            try :
                EKC =ETO (ETP )
                BG (EKC ,ETH )
                break 
            except ValueError as e :
                ETQ (e )
    ETR (ETS )
    if ((EMF .EMG (ETT )or not ELN (ETE ))and (ERY and ETU >=ENJ ))and ((EMJ (EME )or not ELN (EQP ))or (not ELN (ETM )or not EMJ (ETV ))):
        if ((not EMF .EMG (ETW )or EMQ <ERD )or (ETX <ELM and ENI ))and ((ETY >ETZ or EMF .EMG (EUA ))and (ELN (ESB )or ENI !=ENI )):
            while ESC :
                if ((EMJ (EUB )and ELN (EUC ))and (EUD and EUE >EQG ))and ((not ELN (ELM )or not ETI )or (EMM >=EUF and ELN (EUG ))):
                    try :
                        EKD =ETO (EUH )
                        BE (EKD ,ELV )
                        break 
                    except ValueError as e :
                        EUI (e )
    EKE =CJ (ETH ,ETG )
    EKF =CW (ETH )
    if EKF ==EMR :
        GO (ETH ,EKE ,EKC ,EKD ,ETG )
    elif EKF ==ELL :
        GO (ETH ,EKE ,EKC ,EKD ,ETG ,ESC )

def FI (path ,role_prefix ):
    return ETF (role_prefix ,path )

def EUJ (EUK ,EUL ):
    EKG =CX (EUL )
    if EKG ==ERF :
        return ERM 
    else :
        EKH =EKG .split (ELI )
        for EUM in [ERB ]:
            for EKI in EKH :
                if ((EUC or not EMF .EMG (EUN ))or (not EMF .EMG (EUO )and EUG ))and (EUP and EMJ (EUG )or (not ENA and ELN (ELM ))):
                    EKJ =EKI .split (EON )
                    EKK ,EKL ,EKM =(EKJ [ENZ ],EKJ [EMS ],EKJ [EPP ])
                    if EKK ==EUK or EKL ==EUK :
                        return EKK 
        return EPY 

def DC (path ,name_or_id ):
    return EUJ (name_or_id ,path )

def EUQ (EUR ):
    while EUS :
        if ((not ELN (ERC )or not EMF .EMG (EMS ))or (not EUT and EMJ (EUU )))or (not EMJ (EUV )and EMF .EMG (EQO )or (ELN (EUW )and EPA <EUX )):
            ETQ (EUY )
            EKN =EUZ (EVA )
            EKO =EVB (EVC )
            for EVD in EVE (ESB ,ESW ):
                for EVF in (EVG ,):
                    while (EUN ==ENK and (not EOX )or (not EMF .EMG (EMQ )or EVH !=EUW ))and (not EMF .EMG (EMV )and EVI >EVJ or (EQP and EMF .EMG (EVK ))):
                        while EVL :
                            if ((EMF .EMG (ENJ )and EVM )and (ESV and EMF .EMG (EVN )))and (ELN (ETL )and EUE or (EQP and ENF !=EQQ )):
                                try :
                                    EKP =CP ()
                                    EVO (EVP +EKP )
                                    EKQ =EVB (EVQ )
                                    if EKQ !=EKP :
                                        raise ValueError (EVR )
                                    else :
                                        break 
                                except ValueError as e :
                                    ETQ (e )
                        break 
            EKR =AZ (EUR ,EKN ,EKO )
            if EKR :
                ETQ (EVS )
                EKS =DC (EUR ,EKN )
                return EKS 
            else :
                EVT (EVU )
                return EVV 

def DZ (path ):
    return EUQ (path )

def EVW ():
    EUI (EVX )
    while EVL :
        if (ELN (EVY )and EPL or (EMJ (EVZ )and EWA >=EWB ))or ((EWC ==EWD or not EPO )or (not EMF .EMG (EVR )and EMF .EMG (EWE ))):
            try :
                FL =EWF (EUZ (EWG ))
                if FL in (EOA ,EPP ,ENG ,ERX ,ELM ):
                    return FL 
                else :
                    raise ValueError (EWH )
            except ValueError as e :
                EVT (e )

def GM ():
    return EVW ()

def EWI (EWJ ,EWK ,EWL ,EWM ,EWN ,EWO ,EWP ,EWQ ):
    while EUS :
        if (ENI and (not EWR )or (EPL and EWS >EOY ))or ((EMF .EMG (ESR )or not ETD )and (ENF !=EWT or not EUP )):
            EKT =GM ()
            if EKT ==EVK :
                ETR (EWU )
                break 
            elif EKT ==EWV :
                try :
                    EKU =EOZ (ETO (EWW ))
                    if EKU ==EOA :
                        EKV =DZ (EWM )
                        if EKV is not EWX :
                            EWQ (EKV )
                    elif EKU ==EPP :
                        FI (EWM ,EWY )
                        EWZ (EXA )
                    else :
                        raise ValueError (EXB )
                except ValueError as e :
                    EWZ (e )
            elif EKT ==EQE :
                EKV =DZ (EWJ )
                if EKV is not EPY :
                    EWK (EKV )
            elif EKT ==ELU :
                EKV =DZ (EWO )
                if EKV is not EXC :
                    EWN (EKV )
            elif EKT ==EXD :
                EKV =DZ (EWP )
                if EKV is not EVV :
                    EWL (EKV )
            else :
                EVO (EXE )

def FL (customer_data ,clerk_data ,manager_data ,technician_data ,customer_function ,clerk_function ,manager_function ,technician_function ):
    return EWI (clerk_data ,clerk_function ,technician_function ,customer_data ,manager_function ,manager_data ,technician_data ,customer_function )
if __name__ ==EXF :
    pass 